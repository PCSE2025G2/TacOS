/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2011 - 2020 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * pm/pm.cmm : プロセスマネージャ(PM)の本体、プロセスの生成と管理を行う
 *
 * 2020.09.06 : zmbProc， waitChild を kernel から移動（追加）
 * 2020.08.15 : sleep システムコールを kernel に移動（削除）
 * 2019.12.29 : メモリ保護に対応
 * 2019.11.18 : errno.hmm をインクルードするように変更
 * 2019.01.27 : I/O特権モード追加
 * 2018.01.27 : インクルードファイルの拡張子を .h から .hmm に変更
 * 2017.12.27 : プログラムの体裁を整える
 * 2016.01.12 : copyArgs() の argc を廃止
 * 2016.01.02 : sleep システムコールを追加
 * 2015.12.01 : readTextData() を修正
 * 2015.10.01 : exit() のクローズ忘れの確認を変更
 * 2015.11.17 : exec() でプロセスの FDS 領域を確保するように変更
 * 2015.11.16 : copyArgs()にargv参照配列位置を指すアドレスを追加、nullを格納
 * 2015.09.08 : dispatcher.h のインクルード廃止, codeCpy() 廃止(重村)
 * 2015.09.07 : バイト・ワード単位でファイルから読み出す仕組み
 *              openByte(), getByte(), getWord(), closeByte() を追加
 *              length() 廃止し strlen() を使用するように変更
 *              strncpy() のかわりに strcpy() を使用するように変更(重村)
 * 2015.09.05 : newProc()後、PCBの初期化が完了して schProc() を呼ぶように(重村)
 * 2015.09.03 : receive() が LINK を返すので getLink() の使用を中止(重村)
 * 2015.08.20 : strcopy() を util.cmm に移植、strcpy() を codeCpy() に改称
 * 2015.08.19 : 定数の定義を exeFile.h に移植
 * 2015.06.30 : exec ルーチン内にコマンド行引数の設定を実装
 * 2015.06.04 : ユーザモード時のスタックサイズは EXE ファイルの
 *              ヘッダから取得するように変更
 * 2015.05.27 : IPC のセマフォ使用化による変更
 *              (ランデブ内クライアント PCB 取得、exit ルーチン）
 * 2015.05.22 : exit と wait を修正(すぐに結果を返し、wait ルーチンを繰り返す)
 * 2015.05.08 : システムコールの種類を示す #define を syscall.h に移植
 * 2015.04.30 : wait システムコールを実装
 * 2015.04.27 : exit システムコールを実装
 * 2015.04.24 : プロセス生成の際プロセスのメモリ領域と
 *              PCB 領域の2つに分けてメモリを確保するように変更
 * 2015.04.21 : exec システムコールを実装
 * 2015.03.18 : プロセス毎のスタックをユーザモード用と
 *              カーネルモード用に分けたことによる修正
 * 2015.03.10 : sysExec() からカーネル内の empProcNum() の呼び出しを廃止
 * 2015.02.11 : 村田開発開始
 */

#include <errno.hmm>
#include <util.hmm>
#include <kernel.hmm>
#include <dispatcher.hmm>
#include <syscall.hmm>
#include <mm.hmm>
#include <fs.hmm>
#include <errno.hmm>
#include "pm.hmm"
#include "exeFile.hmm"

//
// ページテーブルの構造に関係する定数やマクロ
//
#define DBIT 0x0800                                     // Dirty(D)ビット
#define RBIT 0x1000                                     // Reference(R)ビット
#define SBIT 0x2000                                     // Sticky(S)ビット
#define VBIT 0x8000                                     // Valid(V)ビット
#define RWXBITS 0x0700                                  // Read/Write/Execビット
#define FBITS 0x00ff                                    // Frame番号
#define V(pcb, pNum) (((pcb).pageTable[pNum]&VBIT)!=0)  // Vビットのテスト
#define S(pdb, pNum) (((pcb).pageTable[pNum]&SBIT)!=0)  // Sビットのテスト
#define FRAME(pcb,pNum) ((pcb).pageTable[pNum]&FBITS)   // フレーム番号

// PM は単一プロセスで実行されるので、ほとんどのグローバル変数アクセスで
// 排他を気にしなくて良い

//-----------------------------------------------------------------------------
// ワード単位の read (EXE ファイル用なのでビッグエンディアンとして処理する)
//-----------------------------------------------------------------------------
int[] buf = array(1);                               // 1ワードの読込みバッファ
int fd      = -1;                                   // FS で使用する FD
boolean eof = true;                                 // EOF に達したか

int getWord() {
  eof = read(fd, buf, 2)<=0;
  return buf[0];
}

//-----------------------------------------------------------------------------
// exec システムコール
//-----------------------------------------------------------------------------
// プロセスを生成する
//   プロセスのメモリ領域の配置は以下の順（二つに分けて確保する）
//     テキスト→ データ→ BSS → ユーザスタック(メモリ空間)
//     PCB → カーネルスタック                  (プロセスデータ)
//   EXE ファイルは FAT ファイルシステムと違い、ビッグエンディアンである

// EXE ファイルのヘッダから読みだしたデータ
int magic;                                          // マジック番号
int textSiz;                                        // TEXT セグメントサイズ
int dataSiz;                                        // DATA セグメントサイズ
int bssSiz;                                         // BSS  セグメントサイズ

// EXE ファイルのヘッダから上記のデータを読み出す
int readHeader() {
  magic   = getWord();                              // マジック番号
  if (magic!=UMAGIC && magic!=IMAGIC)               // マジック番号をチェック
    return EMAGIC;                                  //   不正なマジック番号
  textSiz     = getWord();                          // TEXT セグメントサイズ
  dataSiz     = getWord();                          // DATA セグメントサイズ
  bssSiz      = getWord();                          // BSS  セグメントサイズ
  if (eof) return ENOEXEC;                          // ファイルが短い
  return 0;                                         // 正常終了
}

// ページ入れ替え禁止ビット(Sticky bit)の設定
void setSticky(int pNum, PCB pcb){
  int entry = pcb.pageTable[pNum]|SBIT;
  pcb.pageTable[pNum] = entry;
} 

// 仮想アドレスを物理アドレスに変換する
int vToP(int vAdr, PCB pcb) {                   
  int pNum = vAdr / PAGESIZ;                        // ページ番号
  int adr  = vAdr % PAGESIZ;                        // ページ内アドレス
  if (!V(pcb, pNum)) return 0;                      // 変換できなかった
  return (FRAME(pcb, pNum)*PAGESIZ)|adr;            // 物理アドレスを返す
}

// プロセス内で解放できるフレームを探す
int searchFrame(PCB pcb) {
  int fNum = -1;
  int lastPage = (pcb.textSiz-1)/PAGESIZ;           // Text Segの最終ページ
  for(int pNum=0; pNum<=lastPage; pNum=pNum+1) {    // Text Segの全ページにつき
    if (V(pcb, pNum) && !S(pcb, pNum)) {            //   V=1,S=0 のページを探す
      fNum = FRAME(pcb, pNum);                      //     解放できるフレーム
      pcb.pageTable[pNum] = 0x0000;                 //     エントリをクリアし
      break;                                        //       フレームを解放する
    } 
  }
  return fNum;                                      // フレーム番号を返す
}                                                   // 見つからなかった場合は-1

// 全プロセスについて解放できるフレームを探す
int searchAllFrame() {
  int fNum = -1;                                    // フレーム番号
  for(int i=0; i<PRC_MAX; i=i+1) {                  // 全てのプロセスについて
    PCB pcb = procTbl[i];                           // PCBを取り出し
    if(pcb != null) {                               // PCBが存在すれば
      fNum = searchFrame(pcb);                      // 解放できるフレームを探す 
      if(fNum >= 0) break;                          // フレームが見つかった
    }
  }
  return fNum;                                      // フレーム番号を返す
}                                                   // 見つからない場合は-1

// フレームを割り当てページテーブルに記憶する
int allocFrame(int pNum, PCB pcb) {
  int fNum = getFrame();                            // フレームを割り当て
  if (fNum < 0) {                                   // 空きフレームがなかったら
    fNum = searchAllFrame();                        // 解放できるフレームを探す
    if (fNum < 0) panic("allocFrame");              // 解放できなかった
  }
  pcb.pageTable[pNum] = VBIT|RWXBITS|fNum;          // V=1,RWX=111,フレーム番号
  return fNum;                                      // 物理アドレスを返す
}

// 1フレームを0でクリアする
void clearFrame(int fNum) {
  int pAdr = (fNum*PAGESIZ)/2;
  for(int i=0; i<PAGESIZ/2; i=i+1) {
    WMEM[pAdr+i] = 0;                               // 物理メモリ(ワード単位)
  }
}

// 該当ページをexeファイルから読み込む
void swapIn(int pNum, int fNum, PCB pcb) {
  int fd = pcb.filedsc;                             // exeファイルのfd
  int r = seek(fd, 0, pNum*PAGESIZ+PAGESIZ);        // ページ位置にseek
  if (r<0) panic("swapIn-seek");                    // seekでエラー
  r = read(fd, _ItoA(fNum*PAGESIZ), PAGESIZ);       // フレームにswap-in
  if (r!=PAGESIZ) panic("swapin-read");             // readに失敗
}

// フレームを配置し物理アドレスを返す
int locateFrame(int vAdr, PCB pcb) {
  int pAdr = vToP(vAdr, pcb);                       // 物理アドレスに変換
  if (pAdr==0) {                                    // フレームない
    int pNum = vAdr/PAGESIZ;                        //  ページ番号を計算
    int fNum = allocFrame(pNum, pcb);               //  フレームを割り当てる
    if (vAdr < pcb.textSiz+pcb.dataSiz) {           //  exeファイルに該当する
      swapIn(pNum, fNum, pcb);                      //   exeファイルを読む
    } else {                                        //  exeファイルに該当しない
      clearFrame(fNum);                             //   フレームをクリア
    }
    pAdr = fNum*PAGESIZ+vAdr%PAGESIZ;               //  物理アドレスを求める
  }
  return pAdr;                                      // 物理アドレスを返す
}

// 指定したアドレスの1バイトを返す
char peekB(int vAdr, PCB pcb) {
  int pAdr = locateFrame(vAdr, pcb);                // vAdrのフレームを準備する
  return MEM[pAdr];                                 // アドレスの1バイトを返す
}

// 指定したアドレスの1ワードを返す
int peekW(int vAdr, PCB pcb) {
  int pAdr = locateFrame(vAdr, pcb);                // vAdrのフレームを準備する
  return WMEM[pAdr/2];                              // アドレスの1ワードを返す
}

// 指定したアドレスに1バイト書き込む
void pokeB(int vAdr, char c, PCB pcb) {
  if(vAdr<pcb.textSiz) panic("pokeB");              // textセグメントならpanic
  int pAdr = locateFrame(vAdr, pcb);                // vAdrのフレームを準備する
  MEM[pAdr] = c;                                    // アドレスに1バイト格納
}

// 指定したアドレスに1ワード書き込む
int pokeW(int vAdr, int word, PCB pcb) {
  if(vAdr<pcb.textSiz) panic("pokeW");              // textセグメントならpanic
  int pAdr = locateFrame(vAdr, pcb);                // vAdrのフレームを準備する
  WMEM[pAdr/2] = word;                              // アドレスに1ワード格納
  return 0;
}

//文字列を仮想空間から読み込む
// !使用後buf[]のfreeを忘れないこと!
int sysPeekS(int vAdr, PCB pcb) {
  int len = 0;
  for (;peekB(vAdr+len,pcb)!='\0';len=len+1)        // 文字列の長さ
    ;
  char[] buf = malloc(len+1);                       // 領域を確保
  for (int i=0;i<=len;i=i+1) {
    buf[i] = peekB(vAdr+i,pcb);                     // bufに文字列コピー
  }
  return _AtoI(buf);
}

// 仮想メモリから物理メモリにnバイト書き込む
int sysPeekM(int vAdr, char[] pAdr, int size, PCB pcb) {
  for (int i=0;i<size;i=i+1) {
    pAdr[i] = peekB(vAdr+i,pcb);                    // 1バイトずつコピー
  }
  return 0;
}

// 物理メモリから仮想メモリにnバイト書き込む
int sysPokeM(int vAdr, char[] pAdr, int size, PCB pcb) {
  // 呼び出した側が書き込みたい仮想アドレス:vAdr
  // 書き込むデータの入った物理アドレス:pAdr
  // 書き込みたいサイズを渡して、物理メモリのデータをユーザ空間に書きこむ
  for (int i=0;i<size;i=i+1) {
    pokeB(vAdr+i, pAdr[i], pcb);                    // 1バイトずつ書き込み
  }
  return 0;                                         // 正常終了
}

// 親プロセスから子プロセスに文字列をコピーする
//   pPcb:親プロセスのPCB、cPcb:子プロセスのPCB
void strCpyVP(int dst, PCB cPcb, int src, PCB pPcb) {
  char c;
  for(int i=0;(c=peekB(src+i,pPcb))!='\0';i=i+1){   // '\0'になるまでコピーする
    pokeB(dst+i,c,cPcb);
  }
}

// スタックに文字列の配列をコピーする (返り値: strAdr)
int copyCA(int[] USP, int index, int strAdr, char[][] ary,
           int size, PCB pPcb, PCB cPcb) {
  for (int i=0; i<size; i=i+1) {                    // すべての要素について
    USP[index + i] = strAdr;                        //   参照配列位置格納
    int str = vToP(_AtoI(ary[i]), pPcb);            //   文字列の実体を取得
    strCpyVP(strAdr, cPcb, str, pPcb);              //   文字列をコピー
    strAdr = strAdr + strLen(_ItoA(str)) + 1;       //   文字列格納位置を進める
  }
  USP[index + size] = 0x0000;                       // null を格納
  return strAdr;
}

// スタックの底に argc, argv, envp, argv[0], ... を格納する
int copyArgsEnvp(char[][] argv, char[][] envp, PCB pPcb, PCB cPcb) {

  // 読み出し用のフレーム確保
  int readFrame = getFrame();
  char[][] argvAdr = _ItoA(readFrame*PAGESIZ); 
  // 文字列読み出し
  int i = 0;
  // argvの文字列読み出し
  int argc = 0;
  while (argv!=null && argv[argc]!=null) {
    int point = i;
    i = i + 2;                                // ポインタ用の1ワード
    char[] buf = _ItoA(sysPeekS(_AtoI(argv[argc]), pPcb));
    argvAdr[i] = buf;
    free(buf);
    i = i + strLen(argv[argc]);
    argvAdr[point] = _ItoA(i);
    argc = argc + 1;
  }
  argvAdr[i] = null;
  i = i + 2;
  // envpの文字列読み出し
  int envs = 0;
  char[][] envpAdr = _ItoA(_AtoI(argvAdr[i]));
  i = 0;
  while (envp!=null && envp[envs]!=null) {
    int point = i;
    i = i + 2;
    char[] buf = _ItoA(sysPeekS(_AtoI(envp[envs]), pPcb));
    envpAdr[i] = buf;
    free(buf);
    i = i + strLen(envp[envs]);
    envpAdr[point] = _ItoA(i);
    envs = envs + 1;
  }
  envpAdr[i] = null;
  i = i + 2;
  // 文字列の長さがPAGESIZを超えたらpanic
  if (i>PAGESIZ) panic("copyArgsEnvp");
  // 子プロセスのff00のフレーム割り付け
  int fNum = allocFrame(0xff00, cPcb);
  int fAdr = fNum*PAGESIZ;

/*
  // 注意: argv, envp は論理アドレスの配列
  // スタックの底に確保する領域のサイズを計算する
  int st = 2 + 2 + 2 + 2 + 2;                       // 文字列以外
  int argc = 0;                                     // コマンド行引数の個数
  while (argv!=null && argv[argc]!=null) {          // コマンド行引数について
    // 親の argv 配列と文字列の領域
    st = st + strLen(_ItoA(vToP(_AtoI(argv[argc]),pPcb)))+1+2;
    argc = argc + 1;                                 //   サイズを合計していく
  }
  int envs = 0;                                     // 環境変数の個数
  while (envp!=null && envp[envs]!=null) {          // 環境変数について
    // 親のP envp 配列と文字列の領域
    st = st + strLen(_ItoA(vToP(_AtoI(envp[envs]),pPcb)))+1+2;
    envs = envs + 1;                                //   サイズを合計していく
  }
  int usp = 0x0000 - ((st+1) & ~1);                 // スタックの終了位置調整

  // スタックの底に確保した領域に argc, argv, envp, ... を書込む
  int[] USP = _ItoA(usp);                           // スタックを表現する配列
  int argvAdr = usp + 2 + 2 + 2;                    // argv 配列の論理アドレス
  int envpAdr = argvAdr + 2*argc + 2;               // envp 配列の論理アドレス
  int strAdr  = envpAdr + 2*envs + 2;               // 文字列の論理アドレス

  USP[0] = argc;                                    // argc 格納
  USP[1] = argvAdr;                                 // argv 参照配列の位置
  USP[2] = envpAdr;                                 // envp 参照配列の位置

  int index = 3;                                    // 配列のインデックス

  // argv の格納
  strAdr = copyCA(USP, index, strAdr, argv, argc, pPcb, cPcb);
  index = index + argc + 1;
  // envp の格納
  strAdr = copyCA(USP, index, strAdr, envp, envs, pPcb, cPcb);
  return usp;
*/
}

// ページテーブルと参照しているフレームを解放する
void freePageTable(PCB pcb) {
  int[] pageTable = pcb.pageTable;                  // ページテーブルのアドレス
  // フレームの解放
  for(int pNum=0; pNum<TOTALPAGE; pNum=pNum+1) {    // ページテーブルのidx
    if(V(pcb, pNum)){                               // Vビットが1なら
      freeFrame(pageTable[pNum]&FBITS);            // フレーム解放
    }
  }
  // ページテーブルの解放
  int fNum =  _AtoI(pageTable)/PAGESIZ;             // アドレスのフレーム番号
  freeFrame(fNum);                                  // フレームを解放
  freeFrame(fNum+1);                                // 2フレーム目を解放
}

// exec システムコールの処理をする
int sysExec(int path, int argv, int envp, PCB pcb) {
  // PCB を確保・初期化し新しいプロセスを実行可能にする
  int pcbSize = sizeof(PCB)+P_KERN_STKSIZ           // PCB とカーネルスタック
                +P_FILE_MAX*sizeof(int);            //   FDの一覧表の領域
  int fd;                                           // オープンの実行結果
  fd = open(_ItoA(path), READ_MODE);                // EXE ファイルをオープン
  if(fd<0){                                         //   見つからなかった 
    return ENOEXEC;
  }
  int r;                                            // 実行結果    
  if ((r=readHeader())!=0) {                        // ヘッダを読む
    close(fd);                                      //   エラー発生
    return r;
  }
  //ページテーブルを確保する
  int pageFrame = get2Frame();
  if(pageFrame < 0){                                // 空きフレームが無かったら
    close(fd);
    return ENOMEM;                                  // エラー発生
  }
  PCB newPcb = malloc(pcbSize);                     // PCBを確保
  if (newPcb==null) {                               //   エラー発生
    freeFrame(pageFrame);                           // フレームを解放
    freeFrame(pageFrame+1);                         // 2フレーム目を解放
    close(fd);
    return ENOMEM;
  }
  
  newPcb.filedsc = fd;                              // .exeのファイルディスクリプタ
  newPcb.textSiz = textSiz;                         // テキストセグメントサイズ
  newPcb.dataSiz = dataSiz;                         // データセグメントサイズ

  int pageTableAdr = pageFrame * PAGESIZ;           // フレーム番号をアドレスに
  int[] pageTable = _ItoA(pageTableAdr);
  newPcb.pageTable = pageTable;                     // PCBにページテーブル登録
  for(int pNum=0; pNum<TOTALPAGE; pNum=pNum+1){     // ページテーブルを初期化
    pageTable[pNum] = 0;
  }

  // コマンド行引数を親プロセスから子プロセスのユーザスタックにコピーする
  int usp = copyArgsEnvp(_ItoA(argv), _ItoA(envp), pcb, newPcb);

  int[] fds = _ItoA(_AtoI(newPcb)+sizeof(PCB)+P_KERN_STKSIZ);

  int priv = EI|USER;                               // 普通はユーザモード
  if (magic==IMAGIC) priv = EI|IPRV;                // I/O特権モード
  newProc(0, pcb.enice, usp, priv, newPcb, fds);    // PCB 等初期化

  newPcb.parent  = pcb;                             // 親プロセスを設定
  schProc(newPcb);                                  // プロセスを実行可能に
  return newPcb.pid;                                // PID を返す
}

// スワップイン(またはフレーム割り当て)し、入れ替え禁止ビットを1にする
int sysLoad(int vAdr, PCB pcb) {
  int pAdr = locateFrame(vAdr, pcb);                // vAdrのフレームを準備する
  setSticky(vAdr/PAGESIZ, pcb);                     // S=1
  return pAdr;                                      // 物理アドレス
}

//-----------------------------------------------------------------------------
// プロセスマネージャーの本体(ここで各システムコールを実行する)
//-----------------------------------------------------------------------------


int pmSysCall(int op, int prm1, int prm2, int prm3, PCB pcb) {
  int r = -1;
  if (op==EXEC) { // exec(path,argv,envp,parent)
    r = sysExec(prm1, prm2, prm3, pcb);
  } else if (op==LOAD) {
    r = sysLoad(prm1, pcb);
  } else if (op==PEEKS) {
    r = sysPeekS(prm1, pcb);
  } else if (op==PEEKM) {
    r = sysPeekM(prm1, _ItoA(prm2), prm3, pcb);
  } else if (op==POKEW) {
    r = pokeW(prm1, prm2, pcb);
  } else if (op==POKEM) {
    r = sysPokeM(prm1, _ItoA(prm2), prm3, pcb);
  } else {
    r = -1;                                         // どれでもなければエラー
  }
  return r;
}

// プロセスマネージャサーバのメインルーチン
public void pmMain() {
  pmLink = newLink();                               // リンクを生成する
  while (true) {                                    // システムコールを待つ
    Link l = receive(pmLink);                       // システムコールを受信
    int r=pmSysCall(l.op,l.prm1,l.prm2,l.prm3,l.client);// システムコール実行
    send(pmLink, r);                                // 結果を返す
  }
}

//-----------------------------------------------------------------------------
// ユーザプロセスのシステムコール入口
//   以下は、ユーザプロセスのコンテキストで実行されるので、
//   原則 PM のグローバル変数にアクセスしてはならない
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// peekS, peekM, pokeM システムコール
//-----------------------------------------------------------------------------
public char[] peekS(int vAdr) {
   int str = sndrec(pmLink,PEEKS, vAdr, 0, 0);
   return _ItoA(str);
}

public int peekM(int vAdr, void[] pAdr, int size) {
  int r = sndrec(pmLink,PEEKM, vAdr, _AtoI(pAdr), size);
  return r;
}

public int pokeM(int vAdr, void[] pAdr, int size) {
  int r = sndrec(pmLink,POKEM, vAdr, _AtoI(pAdr), size);
  return r;
}

//-----------------------------------------------------------------------------
//  LOAD システムコール
//-----------------------------------------------------------------------------
// swap-inを行い,StickyビットをONにする
public int load(int vAdr) {
  int r = sndrec(pmLink,LOAD, vAdr, 0, 0);
  return r;
}

//-----------------------------------------------------------------------------
// RELEASE関数 (ユーザプロセスのコンテキストで実行)
//-----------------------------------------------------------------------------
// StickyビットをOFFにする
public void release(int pNum){
  int entry = curProc.pageTable[pNum]&0xdfff;
  curProc.pageTable[pNum] = entry;
} 

//-----------------------------------------------------------------------------
// exec システムコールはサーバプロセスに処理させる
//-----------------------------------------------------------------------------
public int exec(char[] path, char[][] argv, char[][] envp) {
  char[] str = peekS(_AtoI(path));
  int r=sndrec(pmLink,EXEC, _AtoI(str), _AtoI(argv), _AtoI(envp));
  free(str);
  return r;                                         // 新しい子の PID を返す
}

//-----------------------------------------------------------------------------
// exit システムコールはユーザプロセスが自ら処理する（ユーザプロセスのコンテキストで実行）
//-----------------------------------------------------------------------------
// 現在のプロセスの子プロセスの PCB を返す(割込み禁止で呼出す)
//   ZOMBIE の子プロセスがあれば優先的に選択しそれの PCB を返す
//   子プロセスが全く存在しない場合は null を返す
PCB srchChild() {
  PCB child = null;                                 // 子プロセスなし
  for(int i=0; i<PRC_MAX; i=i+1) {                  // 全てのプロセスについて
    PCB p = procTbl[i];                             //   子プロセスかチェック
    if(p!=null && p.parent==curProc) {              //     子プロセスを発見
      child = p;                                    //       子プロセスあり
      if(p.stat==P_ZOMBIE)                          //       ゾンビ(exit 済)なら
        break;                                      //         これで決定
    }
  }
  return child;
}

// 現在のプロセスをゾンビにする(カレントプロセスが exit の後半で呼出す)
void zmbProc() {
  int r = setPri(DI|KERN);                          // 割り込み禁止、カーネル

  // もしタイマーが稼働中なら止める
  // if (curProc.evtCnt>0) ...  将来 alarm を実装すると必要になる？

  // 子プロセスの親を INIT に変更する
  for (int i=0; i<PRC_MAX; i=i+1) {
    PCB p = procTbl[i];                             // 全プロセスについて
    if (p!=null && p.parent==curProc)               //   自分の子プロセスなら
      p.parent = initProc;                          //     親を INIT に変更する
  }

  // もし親プロセスが先に wait していたら起こす
  if (curProc.parent.evtCnt == -1)                  // 親が wait していたら
    iSemV(curProc.parent.evtSem);                   //   V 操作で起こす

  // 自身の PCB を後片付けしプロセスを終了
  freeSem(curProc.evtSem);                          // セマフォを返却し
  delProc(curProc);                                 // 実行可能列から外す
  curProc.stat = P_ZOMBIE;                          // ゾンビに変更
  yield();                                          // CPUを解放する
  panic("zmbProc");                                 // ゾンビが生き返った
}

public void exit(int status) {
  for (int i=0; i<P_FILE_MAX; i=i+1)                // クローズ忘れがあれば
    if (curProc.fds[i]!=-1) close(i);               //   クローズする

  curProc.exitStat = status;                        // 終了ステータスを格納
  zmbProc();                                        // 自身をゾンビにする
  //panic("exit");  ここは実行されない
}

//-----------------------------------------------------------------------------
// wait システムコールはユーザプロセスが自ら処理する（ユーザプロセスのコンテキストで実行）
//-----------------------------------------------------------------------------
// 終了した子プロセスを見つけ procTbl[] から抹消した後で PCB を返す
//   子プロセスが存在しない場合は null を返す
//   自身が wait システムコールの処理から呼出す
PCB waitChild() {
  int r = setPri(DI|KERN);                          // 割り込み禁止、カーネル
  PCB p = srchChild();                              // 子プロセスを探す
  if (p!=null && p.stat!=P_ZOMBIE) {                // 子プロセスあるが
    curProc.evtCnt = -1;                            //   ゾンビではない
    semP(curProc.evtSem);                           //  子プロセス待ち状態
    p = srchChild();                                //  子プロセスを探す
    if (p==null || p.stat!=P_ZOMBIE)                //  ゾンビな子が居ないのに
      panic("waitChild");                           //    起こされたら OS にバグ
  }
  if (p!=null)                                      // 子プロセスが見つかった
    procTbl[p.idx] = null;                          // エントリを削除する
  setPri(r);                                        // 割り込み状態を復元する
  return p;
}

public int wait(int[] sta) {
  int r = ECHILD;                                   // 一旦、エラー番号を設定
  PCB child = waitChild();                          // 子プロセスの終了を待つ
  if (child!=null) {                                // 子プロセスが終了した
    //   終了ステータスをコピー
    sndrec(pmLink,POKEW,_AtoI(sta),child.exitStat,0);
    r = child.pid;                                  //   free する前に記録
    free(child);                                    //   PCB 領域を解放する
  }
  return r;                                         // 終了したプロセスの PID
}

//-----------------------------------------------------------------------------
// TLBミスはユーザプロセスが自ら処理する（ユーザプロセスのコンテキストで実行）
//-----------------------------------------------------------------------------
int emptyTlb() {
  for (int i=0x82;i<=0x9E;i=i+2) {
    if ((in(i)&VBIT)==0) return i-2;                // V=1
  }
  return -1;
}

int quietTlb() {
  for (int i=0x82;i<=0x9E;i=i+2) {
    if ((in(i)&(VBIT|RBIT))==VBIT) return i-2;      // V=1,R=0を探す
  }
  return -1;
}

interrupt tlbMiss() {
  // curProcのページテーブルを探索して目的のアドレスのエントリがあるか探す。
  // in(A6)の下位バイトがページ番号
  int[] pageTable = curProc.pageTable;              // ページテーブルのアドレス
  int pNum = in(0xA6);                              // ページ番号
  if (!V(curProc, pNum)) {                          // V=0ならページフォールト
    // pmプロセスにswap-inさせる
    int fNum=load(pNum*PAGESIZ);
    if (fNum<0) panic("tlbMiss");                   // 失敗したら
    release(pNum);                                  //stickyビットを0にする
  }
  int entry = pageTable[pNum];                      // エントリの取り出し
  int tlbAdr = emptyTlb();                          // V=0のエントリを探す
  if (tlbAdr<0) tlbAdr = quietTlb();                // V=1,R=0のエントリを探す
  if (tlbAdr<0) {                                   // 見つからなかったら
    tlbAdr = 0x80 + (rand() & 0xe);                 // 乱数で選ぶ
    int sBit = pageTable[in(tlbAdr)]&0x20;
    pageTable[in(tlbAdr)] = in(tlbAdr+2)|sBit;      // ページテーブルに書き戻す
  }
  out(tlbAdr, pNum);                                // TLBを設定する
  out(tlbAdr+2, entry);
}
